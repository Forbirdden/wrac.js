class WRAC{constructor(e){this.url=e,this.ws=null,this.events={},this._pendingResolve={},this._lastReceivedMessages=[],this._openRequested=!1}connect(){this.ws&&1===this.ws.readyState||(this.ws&&(this.ws.onclose=null,this.ws.close()),this._openRequested=!0,this.ws=new WebSocket(this.url),this.ws.binaryType="arraybuffer",this.ws.onopen=()=>{this._openRequested&&this._emit("open")},this.ws.onerror=e=>{this._emit("error",e)},this.ws.onclose=e=>{this._emit("close",e)},this.ws.onmessage=e=>{this._handleMessage(e.data)})}disconnect(){this.ws&&(this._openRequested=!1,this.ws.close())}on(e,s){this.events[e]||(this.events[e]=[]),this.events[e].push(s)}off(e,s){this.events[e]&&(this.events[e]=this.events[e].filter((e=>e!==s)))}sendMessage(e){const s=(new TextEncoder).encode(e),t=new Uint8Array(1+s.length);t[0]=1,t.set(s,1),this._send(t)}sendAuthMessage(e,s,t){const n=new TextEncoder,i=n.encode(e),o=n.encode(s),d=n.encode(t),r=new Uint8Array(1+i.length+1+o.length+1+d.length);return r[0]=2,r.set(i,1),r[1+i.length]=10,r.set(o,1+i.length+1),r[1+i.length+1+o.length]=10,r.set(d,1+i.length+1+o.length+1),new Promise((e=>{this._pendingResolve.sendAuthMessage=e,this._send(r)}))}register(e,s){const t=new TextEncoder,n=t.encode(e),i=t.encode(s),o=new Uint8Array(1+n.length+1+i.length);return o[0]=3,o.set(n,1),o[1+n.length]=10,o.set(i,1+n.length+1),new Promise((e=>{this._pendingResolve.register=e,this._send(o)}))}getMessageSize(){return new Promise((e=>{this._pendingResolve.getMessageSize=e,this._send(new Uint8Array([0]))}))}readAllMessages(){return new Promise((e=>{this._pendingResolve.readAllMessages=e,this._send(new Uint8Array([0,1]))}))}readChunkedMessages(e){const s=String(e),t=(new TextEncoder).encode(s),n=new Uint8Array(2+t.length);return n[0]=0,n[1]=2,n.set(t,2),new Promise((e=>{this._pendingResolve.readChunkedMessages=e,this._send(n)}))}getServerInfo(){return new Promise((e=>{this._pendingResolve.getServerInfo=e,this._send(new Uint8Array([105]))}))}_emit(e,...s){if(this.events[e])for(const t of this.events[e])t(...s)}_send(e){if(!this.ws||1!==this.ws.readyState)throw new Error("WebSocket is not open");this.ws.send(e)}_handleMessage(e){if("string"==typeof e)return;const s=new Uint8Array(e);if(1===s.length)switch(s[0]){case 1:return this._pendingResolve.sendAuthMessage?(this._pendingResolve.sendAuthMessage("no_user"),void delete this._pendingResolve.sendAuthMessage):this._pendingResolve.register?(this._pendingResolve.register("username_taken"),void delete this._pendingResolve.register):void 0;case 2:return this._pendingResolve.sendAuthMessage?(this._pendingResolve.sendAuthMessage("bad_pass"),void delete this._pendingResolve.sendAuthMessage):void 0}const t=(new TextDecoder).decode(s).trim();if(/^\d+$/.test(t)&&this._pendingResolve.getMessageSize)return this._pendingResolve.getMessageSize(parseInt(t,10)),void delete this._pendingResolve.getMessageSize;if(this._pendingResolve.readAllMessages||this._pendingResolve.readChunkedMessages){const e=t.split("\n").filter(Boolean);return this._pendingResolve.readAllMessages&&(this._pendingResolve.readAllMessages(e),delete this._pendingResolve.readAllMessages),this._pendingResolve.readChunkedMessages&&(this._pendingResolve.readChunkedMessages(e),delete this._pendingResolve.readChunkedMessages),this._lastReceivedMessages=e,void this._emit("messages",e)}if(this._pendingResolve.getServerInfo&&s.length>1){const e=s[0],t=(new TextDecoder).decode(s.slice(1));return this._pendingResolve.getServerInfo({version:e,name:t}),void delete this._pendingResolve.getServerInfo}const n=t.split("\n").filter(Boolean);this._lastReceivedMessages=n,this._emit("messages",n)}}"undefined"!=typeof module&&void 0!==module.exports?module.exports=WRAC:window.WRAC=WRAC;
